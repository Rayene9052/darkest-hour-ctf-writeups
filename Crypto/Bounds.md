#  Bounds

**Description:** Set boundaries it will make your love life easier

**Author:** Nedim

Wrap what you'll find in `Securinets{}`

## Challenge Code

```
from Crypto.Util.number import getPrime, bytes_to_long

p = getPrime(1050)
q = getPrime(1050)
n = p * q
e = 17


flag = #**********

assert len(flag) == 16
assert flag[0:2] == b"*t"
m = bytes_to_long(flag)
ciphertext = pow(m, e, n)


print(f"n = {n}")
print(f"e = {e}")
print(f"ciphertext = {ciphertext}")


""" OUTPUT : 
n = 68985132076321649157608692131255728587158185722181445880948249717091597846487833787186023285196440084950080300041734118210866545501672413302348209144359668432994451906588705915322111950352902871508370525331267433521716483392054551829314989064477558616196246498234055760665719873571643081993355771773957916257681207004722245901672742884529831401891014030482481029614100998421867527601555248062856719389709373670628911233873661157528351249254209292422531778520780541322836206202727211383286655681415328515946554657094574338133069733920972866111278014109981667277625632946673156706439480987490578769741642117060436725771400002746461531
e = 17
ciphertext = 68647164594668438330909240867812037296554103056294491768441266685474109920969552957214226004181278128546333455269862088116311457830154951702988621558827590908201221509760617492167891367150826075525355256604569407738069796637844923147368311489263594433078735049302132316997200420838369765451800100431969822979385901622058144490830120813526401518930697232441101164866583314616230902820750473834895229740313738615504799534363477579768514113854173090326575519302276865187218346674552042530004231685607845294507296401878572245275539917638299206114305210954930877672858775726112199508701393992180790390348659969088782358943604706534096768
"""
```
We are given RSA encryption setup where we have two large prime RSA numbers p and q which are generated to get n=p.q . The trick here is that e=17 which is a small number . We all know that in RSA C= m^e (mod n) which is equivalent to C=m^e+ k*n  . So the idea here is that we need to bruteforce the k .
First , i tried hopelessly to literally bruteforce from zero to idk what number but the programm kept running for almost 45 minutes without a result . So i knew that i forgot something , which is that in the source code they gave us two hints on the flag :
-It is 16 bytes long
-It starts with "*t"
So the idea here is to limit the range of k to what gives us that the flag starts with "*t" 
Thus, \( m \) lies in the range \([L, U]\), meaning \( m^e \) lies in the range \([L^e, U^e]\). Since \( m^e = c + k \cdot n \), this allows us to restrict \( k \) to:

\[
k_{\text{min}} = \frac{L^e - c + n - 1}{n}
\]

\[
k_{\text{max}} = \frac{U^e - c}{n}
\]
## Solver 
 ```
 import gmpy2

# Given RSA parameters
n = 68985132076321649157608692131255728587158185722181445880948249717091597846487833787186023285196440084950080300041734118210866545501672413302348209144359668432994451906588705915322111950352902871508370525331267433521716483392054551829314989064477558616196246498234055760665719873571643081993355771773957916257681207004722245901672742884529831401891014030482481029614100998421867527601555248062856719389709373670628911233873661157528351249254209292422531778520780541322836206202727211383286655681415328515946554657094574338133069733920972866111278014109981667277625632946673156706439480987490578769741642117060436725771400002746461531
e = 17
c = 68647164594668438330909240867812037296554103056294491768441266685474109920969552957214226004181278128546333455269862088116311457830154951702988621558827590908201221509760617492167891367150826075525355256604569407738069796637844923147368311489263594433078735049302132316997200420838369765451800100431969822979385901622058144490830120813526401518930697232441101164866583314616230902820750473834895229740313738615504799534363477579768514113854173090326575519302276865187218346674552042530004231685607845294507296401878572245275539917638299206114305210954930877672858775726112199508701393992180790390348659969088782358943604706534096768

# HINT: The flag is 16 bytes long and starts with b"*t".
# That means m (the integer corresponding to the flag) satisfies:
#   L <= m <= U
L = int.from_bytes(b"*t" + b"\x00" * 14, byteorder="big")
U = int.from_bytes(b"*t" + b"\xff" * 14, byteorder="big")

# Since m^e = c + k*n, we have:
#   c + k*n in [L^e, U^e].
# So we can compute a (hopefully small) range for k.
k_min = (pow(L, e) - c + n - 1) // n  # ceiling division
k_max = (pow(U, e) - c) // n

print(f"Possible k values in range: {k_min} to {k_max}")

# Now iterate over the possible k values in this range.
for k in range(k_min, k_max + 1):
    candidate = c + k * n
    m_root, exact = gmpy2.iroot(candidate, e)
    if exact:
        m = int(m_root)
        flag = m.to_bytes(16, byteorder="big")
        if flag.startswith(b"*t"):
            print("Flag:", flag)
            break


 ```